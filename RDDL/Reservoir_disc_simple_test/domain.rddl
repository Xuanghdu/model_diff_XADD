domain reservoir_control_dis {

	requirements = {
		concurrent,           // different reservoirs are controlled independently
		reward-deterministic, // this domain does not use a stochastic reward
		intermediate-nodes,   // this domain uses intermediate pvariable nodes
		constrained-state     // this domain uses state constraints
	};

	types {
		reservoir: object;
	};

    pvariables {

		// Constants
        TOP_RES(reservoir): { non-fluent, real, default = 100.0 }; // Overflowing amount
        MAX_LEVEL(reservoir): { non-fluent, real, default = 80.0 };  // The upper bound for desired reservoir level
		MIN_LEVEL(reservoir): { non-fluent, real, default = 20.0 };  // The lower bound for desired reservoir level
        RELEASE_VALUE(reservoir): {non-fluent, real, default = 5 }; // 
        RAIN_VALUE(reservoir): {non-fluent, real, default = 2 };
        RAIN_AFTER_RAIN(reservoir): {non-fluent, real, default=0.5};
        RAIN_AFTER_NO_RAIN(RESERVOIR): {NON-FLUENT, ... }
        COST_OVERFLOW(reservoir) : { non-fluent, real, default =  -5.0 }; // Penalty per unit of level < MIN_LEVEL
        
        // interm fluents
        rain(reservoir):   {interm-fluent, real}; // Amount of rain fell
        is_rain(reservoir): {state-fluent, bool, default=false };

        // State fluents
        rlevel(reservoir): {state-fluent, real, default = 50.0 }; // Reservoir level



        // Action fluents
        release(reservoir): { action-fluent, bool, default = false }; // Action to set outflow of reservoir
        do_nothing(reservoir): { action-fluent, bool, default = false };
    };

    cpfs {

        rain(?r) = 3.0;
        is_rain(?r) = IF IS_RAIN(?R)
                            THEN BERNOULLI(RAIN_AFTER_RAIN(?R))
                    ELSE
                        BERNOULLI(RAIN_AFTER_NO_RAIN(?R))
        
        rlevel'(?r) = if (release(?r))
                    then min[TOP_RES(?r), max[0, rlevel(?r) + rain(?r)]]
                    else if (do_nothing(?r))
                    then min[TOP_RES(?r), max[0, rlevel(?r) + rain(?r) - RELEASE_VALUE(?r)]]
                    else rlevel(?r);

    };

    reward = (sum_{?r: reservoir} [if ((rlevel(?r) >= MIN_LEVEL(?r)) ^ (rlevel(?r) <= MAX_LEVEL(?r)))
                                   then 1
                                    else 0
                                   ]);

	state-invariants {

	};

}